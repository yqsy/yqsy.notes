---
title: Linux服务器编程框架
date: 2017-11-10 20:15:44
categories: [网络相关]
---

<!-- TOC -->

- [1. 基本模块](#1-基本模块)
- [2. 同步异步和阻塞非阻塞](#2-同步异步和阻塞非阻塞)
- [3. 两种高效的事件处理模式](#3-两种高效的事件处理模式)
    - [3.1. Reactor模式](#31-reactor模式)
    - [3.2. Proactor模式](#32-proactor模式)
    - [3.3. 模拟Proactor模式](#33-模拟proactor模式)
- [4. 两种高效的并发模式](#4-两种高效的并发模式)
    - [4.1. 半同步/半异步模式](#41-半同步半异步模式)
        - [4.1.1. 半同步/半反应堆](#411-半同步半反应堆)
        - [4.1.2. 高效的半同步/半异步模式](#412-高效的半同步半异步模式)
    - [4.2. 领导者/追随者模式](#42-领导者追随者模式)

<!-- /TOC -->

<a id="markdown-1-基本模块" name="1-基本模块"></a>
# 1. 基本模块

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_112746.png)

模块|单个服务器程序|服务器机群
-|-|-
I/O处理单元|处理客户连接,读写网络数据|作为接入服务器,实现负载均衡
逻辑单元|业务进程或线程|逻辑服务器
网络存储单元|本地数据库,文件或缓存|数据库服务器
请求队列|各单元之间的通信方式|各服务器之间的永久TCP连接

请求队列是各单元之间的通信方式的抽象,I/O处理单元接收到客户请求时,需要以某种方式通知一个逻辑单元来处理该请求.同样,多个逻辑单元同时访问一个存储单元时,也需要采用某种机制来协调处理竞态条件.请求队列通常被实现为池的一部分.对于服务器机群而言,请求队列是各台服务器之间预先建立的,静态的,永久的TCP连接,这种TCP连接能提高服务器时间交换数据的效率,因为它避免了动态建立TCP连接导致的额外的系统开销.

<a id="markdown-2-同步异步和阻塞非阻塞" name="2-同步异步和阻塞非阻塞"></a>
# 2. 同步异步和阻塞非阻塞

在I/O模型中,`同步`和`异步`区分的是内核向应用程序通知的是何种I/O事件(是就绪事件还是完成事件),以及由谁来完成I/O读写(是应用程序还是内核)

![](http://ouxarji35.bkt.clouddn.com/snipaste_20170923_093658.png)

<a id="markdown-3-两种高效的事件处理模式" name="3-两种高效的事件处理模式"></a>
# 3. 两种高效的事件处理模式

服务器程序通常需要处理三类事件:`I/O事件`,`信号`,`定时事件`

<a id="markdown-31-reactor模式" name="31-reactor模式"></a>
## 3.1. Reactor模式

Reactor是这样一种模式,它要求主线程(I/O处理单元,下同)`只负责监听文件描述上是否有事件发生`,有的话立即将该事件通知工作线程(逻辑单元),除此之外,主线程不做任何其他实质性的工作.工作线程负责`读写数据`,`接受新的连接`,`以及处理客户请求`

* 1) 主线程往epoll内核事件表中注册socket上的读就绪事件
* 2) 主线程调用epoll_wait等待socket上有数据可读
* 3) 当socket上有数据可读时,epoll_wait通知主线程,`主线程则将socket可读事件放入请求队列`
* 4) 睡眠在请求队列上的某个工作线程被唤醒,它从socket读取数据,`并处理客户请求,然后往epoll内核事件表中注册该socket上的写就绪事件`
* 5) 主线程调用epoll_wait等待socket可写
* 6) 当socket可写时,epoll_wait通知主线程,`主线程将socket可写事件放入请求队列`
* 7) 睡眠在请求队列上的某个工作线程被唤醒,它往socket上写入服务器处理客户请求的结果

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_134906.png)

工作线程从请求队列中取出事件后,将根据事件的类型来决定如何处理它:对于可读事件,执行读数据和处理请求的操作,对于可写事件,执行写数据的操作,没必要区分所谓的`读工作线程`和`写工作线程`

<a id="markdown-32-proactor模式" name="32-proactor模式"></a>
## 3.2. Proactor模式

Proactor模式将所有I/O操作交给主线程和内核来处理,工作线程仅仅负责业务逻辑

* 1) 主线程调用aio_read函数向内核注册socket上的读完成时间,并告诉内核用户读缓冲区的位置,以及读操作完成时如何通知应用程序
* 2) 主线程继续处理其他逻辑
* 3) 当socket上的数据被读入用户缓冲区后,内核将向应用程序发送一个信号,以通知应用程序数据已经可用
* 4) 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求.工作线程处理玩客户请求之后,调用aio_write函数向内核注册socket上的写完成事件,并告诉内核用户写缓冲区的位置,以及写操作完成时如何通知应用程序
* 5) 主线程继续处理其他逻辑
* 6) 当用户缓冲区的数据被写入socket之后,内核将向应用程序发送一个信号,以通知应用程序数据已经发送完毕
* 7) 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理,比如决定是否关闭socket

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_140517.png)

<a id="markdown-33-模拟proactor模式" name="33-模拟proactor模式"></a>
## 3.3. 模拟Proactor模式

使用同步I/O模型模拟出的Proactor模式的工作流程如下:

* 1) 主线程往epoll内核事件表中注册socket上的读就绪事件
* 2) 主线程调用epoll_wait等待socket上有数据可读
* 3) 当socket上有数据可读时,epoll_wait通知主线程,主线程从socket循环读取数据,知道没有更多数据可读,然后将读取到的数据封装成一个请求对象并插入请求队列
* 4) 睡眠在请求队列上的某个工作线程被唤醒,它获得请求对象并处理客户请求,然后往epoll内核事件表中注册socket上的写就绪事件
* 5) 主线程调用epoll_wait等待socket可写
* 6) 当socket可写,epoll_wait通知主线程,主线程往socket上写入服务器处理客户请求的结果

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_141917.png)

<a id="markdown-4-两种高效的并发模式" name="4-两种高效的并发模式"></a>
# 4. 两种高效的并发模式

<a id="markdown-41-半同步半异步模式" name="41-半同步半异步模式"></a>
## 4.1. 半同步/半异步模式

`同步`指的是程序完全按照代码序列的顺序执行,`异步`指的是程序的执行需要由系统事件来驱动.常见的系统事件包括中断,信号等.

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_143528.png)

* 同步: 虽然效率相对较低,实时性较差,但逻辑简单
* 异步: 相对复杂,难于调试和扩展,不适合于大量的并发

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_164935.png)

* http://www.kircher-schwanninger.de/michael/publications/lf.pdf
* https://www.zhihu.com/question/29751072/answer/45496897

在IO线程面异步,把数据塞进一个同步队列,然后demultiplexing,一堆线程同步地处理数据.相比一个线程一个链接的模式,省去了很多线程维护开销,在进队列/出队列的时候,免不了会有race condition

<a id="markdown-411-半同步半反应堆" name="411-半同步半反应堆"></a>
### 4.1.1. 半同步/半反应堆

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_154909.png)

主线程插入请求队列中的任务是就绪的连接socket,事件处理模式是Reactor:它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答.

缺点:
* 主线程和工作线程共享请求队列,主线程往请求队列中添加任务,或者工作线程从请求队列中取出任务,都需要对请求队列加锁保护,从而白白耗费CPU时间
* 每个工作线程在同一时间只能处理一个客户请求,如果客户数量较多,而工作线程较少,则请求队列中奖堆积很多任务对象,客户端的相应速度将越来越慢.如果通过增加工作线程来解决这一问题,则工作线程的切换也将耗费大量CPU时间

<a id="markdown-412-高效的半同步半异步模式" name="412-高效的半同步半异步模式"></a>
### 4.1.2. 高效的半同步/半异步模式

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_160147.png)

主线程只管监听socket,连接socket由工作线程来管理,当有新的连接到来时,主线程就接受并将新返回的连接socket派发给某个工作线程,此后该新socket上的任何I/O操作都由被选中的工作线程来处理,知道客户关闭连接.


<a id="markdown-42-领导者追随者模式" name="42-领导者追随者模式"></a>
## 4.2. 领导者/追随者模式
领导者/追随者模式是多个工作线程轮流获得事件源集合,轮流监听,分发并处理事件的一种模式.在任意时间点,程序都仅有一个领导者线程,它负责监听I/O事件.而其他线程则都是追随者,它们休眠在线程池中等待成为新的领导者.当前的领导者如果检测到I/O事件,首先要从线程池中推选出新的领导者线程,然后处理I/O事件.此时,新的领导者等待新的I/O事件,而原来的领导者则处理I/O事件,二者实现了并发

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_160818.png)

