---
title: Linux服务器编程框架
date: 2017-11-10 20:15:44
categories: [网络相关]
---

<!-- TOC -->

- [1. 基本模块](#1-基本模块)
- [2. 同步异步和阻塞非阻塞](#2-同步异步和阻塞非阻塞)
- [3. 两种高效的事件处理模式](#3-两种高效的事件处理模式)
    - [3.1. Reactor模式](#31-reactor模式)
    - [3.2. Proactor模式](#32-proactor模式)
    - [3.3. 模拟Proactor模式](#33-模拟proactor模式)

<!-- /TOC -->

<a id="markdown-1-基本模块" name="1-基本模块"></a>
# 1. 基本模块

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_112746.png)

模块|单个服务器程序|服务器机群
-|-|-
I/O处理单元|处理客户连接,读写网络数据|作为接入服务器,实现负载均衡
逻辑单元|业务进程或线程|逻辑服务器
网络存储单元|本地数据库,文件或缓存|数据库服务器
请求队列|各单元之间的通信方式|各服务器之间的永久TCP连接

请求队列是各单元之间的通信方式的抽象,I/O处理单元接收到客户请求时,需要以某种方式通知一个逻辑单元来处理该请求.同样,多个逻辑单元同时访问一个存储单元时,也需要采用某种机制来协调处理竞态条件.请求队列通常被实现为池的一部分.对于服务器机群而言,请求队列是各台服务器之间预先建立的,静态的,永久的TCP连接,这种TCP连接能提高服务器时间交换数据的效率,因为它避免了动态建立TCP连接导致的额外的系统开销.

<a id="markdown-2-同步异步和阻塞非阻塞" name="2-同步异步和阻塞非阻塞"></a>
# 2. 同步异步和阻塞非阻塞

![](http://ouxarji35.bkt.clouddn.com/snipaste_20170923_093658.png)

<a id="markdown-3-两种高效的事件处理模式" name="3-两种高效的事件处理模式"></a>
# 3. 两种高效的事件处理模式

服务器程序通常需要处理三类事件:`i/O事件`,`信号`,`定时事件`

<a id="markdown-31-reactor模式" name="31-reactor模式"></a>
## 3.1. Reactor模式

Reactor是这样一种模式,它要求主线程(I/O处理单元,下同)`只负责监听文件描述上是否有事件发生`,有的话立即将该事件通知工作线程(逻辑单元),除此之外,主线程不做任何其他实质性的工作.工作线程负责`读写数据`,`接受新的连接`,`以及处理客户请求`

* 1) 主线程往epoll内核事件表中注册socket上的读就绪事件
* 2) 主线程调用epoll_wait等待socket上有数据可读
* 3) 当socket上有数据可读时,epoll_wait通知主线程,`主线程则将socket可读事件放入请求队列`
* 4) 睡眠在请求队列上的某个工作线程被唤醒,它从socket读取数据,`并处理客户请求,然后往epoll内核事件表中注册该socket上的写就绪事件`
* 5) 主线程调用epoll_wait等待socket可写
* 6) 当socket可写时,epoll_wait通知主线程,`主线程将socket可写事件放入请求队列`
* 7) 睡眠在请求队列上的某个工作线程被唤醒,它往socket上写入服务器处理客户请求的结果

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_134906.png)

工作线程从请求队列中取出事件后,将根据事件的类型来决定如何处理它:对于可读事件,执行读数据和处理请求的操作,对于可写事件,执行写数据的操作,没必要区分所谓的`读工作线程`和`写工作线程`

<a id="markdown-32-proactor模式" name="32-proactor模式"></a>
## 3.2. Proactor模式

Proactor模式将所有I/O操作交给主线程和内核来处理,工作线程仅仅负责业务逻辑

* 1) 主线程调用aio_read函数向内核注册socket上的读完成时间,并告诉内核用户读缓冲区的位置,以及读操作完成时如何通知应用程序
* 2) 主线程继续处理其他逻辑
* 3) 当socket上的数据被读入用户缓冲区后,内核将向应用程序发送一个信号,以通知应用程序数据已经可用
* 4) 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求.工作线程处理玩客户请求之后,调用aio_write函数向内核注册socket上的写完成事件,并告诉内核用户写缓冲区的位置,以及写操作完成时如何通知应用程序
* 5) 主线程继续处理其他逻辑
* 6) 当用户缓冲区的数据被写入socket之后,内核将向应用程序发送一个信号,以通知应用程序数据已经发送完毕
* 7) 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理,比如决定是否关闭socket

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_140517.png)

<a id="markdown-33-模拟proactor模式" name="33-模拟proactor模式"></a>
## 3.3. 模拟Proactor模式

使用同步I/O模型模拟出的Proactor模式的工作流程如下:

* 1) 主线程往epoll内核事件表中注册socket上的读就绪事件
* 2) 主线程调用epoll_wait等待socket上有数据可读
* 3) 当socket上有数据可读时,epoll_wait通知主线程,主线程从socket循环读取数据,知道没有更多数据可读,然后将读取到的数据封装成一个请求对象并插入请求队列
* 4) 睡眠在请求队列上的某个工作线程被唤醒,它获得请求对象并处理客户请求,然后往epoll内核事件表中注册socket上的写就绪事件
* 5) 主线程调用epoll_wait等待socket可写
* 6) 当socket可写,epoll_wait通知主线程,主线程往socket上写入服务器处理客户请求的结果

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_141917.png)

