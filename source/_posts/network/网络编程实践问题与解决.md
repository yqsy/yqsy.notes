---
title: 网络编程实践问题与解决
date: 2017-11-29 21:18:19
categories: [网络相关]
---

<!-- TOC -->

- [1. 应用层缓冲区](#1-应用层缓冲区)
- [2. 应用层定时器](#2-应用层定时器)

<!-- /TOC -->

<a id="markdown-1-应用层缓冲区" name="1-应用层缓冲区"></a>
# 1. 应用层缓冲区

我是在实践ttcp的时候发现的,https://github.com/yqsy/linux_socket_test/tree/master/ttcp

问题是在使用非阻塞I/O时,每次触发read信号,read得到是一片流,流在变成包的这一个过程中,有许多状态,状态满足之后才能交给应用层(例如收到足够的字节,收到终结符号).

我的做法是在判断状态达成之后才使用read函数去收取(不断的用`ioctl`获取内核缓冲区可读字节数),所以导致了性能的缓慢

参考陈硕的书籍7.4章节,发现解决这一的问题的方法是应用层缓冲区.


<a id="markdown-2-应用层定时器" name="2-应用层定时器"></a>
# 2. 应用层定时器

使用libevent实现ttcp时发现,ctrl+c退出时,client在FIN_WAIT_1状态了,但是并没有发送FIN出去?所以要维护用户层的定时器
