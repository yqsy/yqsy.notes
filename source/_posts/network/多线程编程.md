---
title: 多线程编程
date: 2017-11-19 22:58:21
categories: [网络相关]
---

<!-- TOC -->

- [1. Linux线程库](#1-linux线程库)
- [2. 函数](#2-函数)
- [3. 同步](#3-同步)
    - [3.1. POSIX信号量](#31-posix信号量)
    - [3.2. 互斥锁(互斥量)](#32-互斥锁互斥量)
        - [3.2.1. 死锁](#321-死锁)
    - [3.3. 条件变量](#33-条件变量)

<!-- /TOC -->


<a id="markdown-1-linux线程库" name="1-linux线程库"></a>
# 1. Linux线程库

Linux上两个最有名的线程库是`LinuxThreads`和`NPTL`,它们都是采用1:1的方式实现的,由于LinuxThreads在开发的时候,Linux内核对线程的支持非常有限,所以其可用性,稳定性以及POSIX兼容性远远不及NPTL.现在Linux上默认使用的线程库是NPTL
```bash
getconf GNU_LIBPTHREAD_VERSION
```

LinuxThreads线程库的内核线程是clone系统调用创建的进程模拟的
* 每个线程拥有不同的PID,因此不符合POSIX规范
* Linux信号处理本来是基于进程的,但现在一个进程内部的所有线程都能而且必须处理信号
* 用户ID,组ID对一个进程的不同线程来说可能是不一样的
* 程序产生的核心转出文件不会包含所有线程的信息,而只包含产生该核心转出文件的线程的信息
* 由于每个线程都是一个进程,因此系统允许的最大进程数就是最大线程数

Linux内核从2.6版本开始,提供了真正的内核线程,新的NPTL线程库也应运而生,相比LinuxThreads,NPTL的主要优势在于:
* 内核线程不再是一个进程,因此避免了很多用进程模拟内核线程导致的语义问题
* 摒弃了管理线程,终止线程,回收线程堆栈等工作都可以由内核来完成
* 由于不存在管理线程,所以一个进程的线程可以运行在不同的CPU上,从而充分利用了多处理器系统的优势
* 线程的同步由内核来完成,隶属于不同进程的线程之间也能共享互斥锁,因此可实现跨进程的线程同步

资料:
* https://linux.die.net/man/7/pthreads

<a id="markdown-2-函数" name="2-函数"></a>
# 2. 函数

* pthread_create: 创建一个线程
* pthread_exit: 通过retval参数向线程的回收者传递其退出信息.它执行完之后不会返回到调用者,而且不会失败
* pthread_join: 一个进程中的所有线程都可以调用pthread_join函数来回收其他线程
* pthread_cancel: 异常终止一个线程,即取消线程

<a id="markdown-3-同步" name="3-同步"></a>
# 3. 同步

<a id="markdown-31-posix信号量" name="31-posix信号量"></a>
## 3.1. POSIX信号量

Linux上信号量API有两组,一组是`System V IPC(进程间)信号量`,另外一组是`POSIX信号量`.两组接口很相似,但不能保证互换.不过原理相同

* sem_init 初始化一个未命名的信号量
* sem_destory 销毁信号量,以释放其占用的内核资源
* sem_wait 以原子操作的方式将信号量的值减1
* sem_trywait和sem_wait
* sem_post 以原子操作的方式将信号量的值加1

资料:
* https://linux.die.net/man/7/sem_overview

<a id="markdown-32-互斥锁互斥量" name="32-互斥锁互斥量"></a>
## 3.2. 互斥锁(互斥量)

* pthread_mutex_init 初始化互斥锁
* pthread_mutex_destroy 销毁互斥锁
* pthread_mutex_lock 以原子操作的方式给一个互斥锁加锁
* pthread_mutex_trylock
* pthread_mutex_lock
* pthread_mutex_unlock

资料:
* https://linux.die.net/man/3/pthread_mutex_init

<a id="markdown-321-死锁" name="321-死锁"></a>
### 3.2.1. 死锁



<a id="markdown-33-条件变量" name="33-条件变量"></a>
## 3.3. 条件变量
