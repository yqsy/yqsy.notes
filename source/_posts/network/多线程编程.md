---
title: 多线程编程
date: 2017-11-19 22:58:21
categories: [网络相关]
---

<!-- TOC -->

- [1. Linux线程库](#1-linux线程库)
- [2. 函数](#2-函数)
- [3. 同步](#3-同步)

<!-- /TOC -->


<a id="markdown-1-linux线程库" name="1-linux线程库"></a>
# 1. Linux线程库

Linux上两个最有名的线程库是`LinuxThreads`和`NPTL`,它们都是采用1:1的方式实现的,由于LinuxThreads在开发的时候,Linux内核对线程的支持非常有限,所以其可用性,稳定性以及POSIX兼容性远远不及NPTL.现在Linux上默认使用的线程库是NPTL
```bash
getconf GNU_LIBPTHREAD_VERSION
```

LinuxThreads线程库的内核线程是clone系统调用创建的进程模拟的
* 每个线程拥有不同的PID,因此不符合POSIX规范
* Linux信号处理本来是基于进程的,但现在一个进程内部的所有线程都能而且必须处理信号
* 用户ID,组ID对一个进程的不同线程来说可能是不一样的
* 程序产生的核心转出文件不会包含所有线程的信息,而只包含产生该核心转出文件的线程的信息
* 由于每个线程都是一个进程,因此系统允许的最大进程数就是最大线程数

Linux内核从2.6版本开始,提供了真正的内核线程,新的NPTL线程库也应运而生,相比LinuxThreads,NPTL的主要优势在于:
* 内核线程不再是一个进程,因此避免了很多用进程模拟内核线程导致的语义问题
* 摒弃了管理线程,终止线程,回收线程堆栈等工作都可以由内核来完成
* 由于不存在管理线程,所以一个进程的线程可以运行在不同的CPU上,从而充分利用了多处理器系统的优势
* 线程的同步由内核来完成,隶属于不同进程的线程之间也能共享互斥锁,因此可实现跨进程的线程同步

资料:
* https://linux.die.net/man/7/pthreads

<a id="markdown-2-函数" name="2-函数"></a>
# 2. 函数

* pthread_create: 创建一个线程
* pthread_exit: 通过retval参数向线程的回收者传递其退出信息.它执行完之后不会返回到调用者,而且不会失败
* pthread_join: 一个进程中的所有线程都可以调用pthread_join函数来回收其他线程
* pthread_cancel: 异常终止一个线程,即取消线程

<a id="markdown-3-同步" name="3-同步"></a>
# 3. 同步

* POSIX信号量
* 互斥量
* 条件变量
