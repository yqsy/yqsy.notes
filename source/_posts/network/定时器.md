---
title: 定时器
date: 2017-11-10 22:15:44
categories: [网络相关]
---

<!-- TOC -->

- [1. 简介](#1-简介)
- [2. SO_RCVTIMEO和SO_SNDTIMEO](#2-so_rcvtimeo和so_sndtimeo)
- [3. SIGALRM信号](#3-sigalrm信号)
    - [3.1. 基于升序链表的定时器](#31-基于升序链表的定时器)
        - [3.1.1. 处理非活动连接](#311-处理非活动连接)
- [4. I/O复用系统调用的超时参数](#4-io复用系统调用的超时参数)
- [5. 高性能定时器](#5-高性能定时器)
    - [5.1. 时间轮](#51-时间轮)
    - [5.2. 时间堆](#52-时间堆)

<!-- /TOC -->

<a id="markdown-1-简介" name="1-简介"></a>
# 1. 简介

网络程序需要处理的第三类事件是定时事件,比如定期检测一个客户连接的活动状态.

有两种高效的管理定时器的容器:时间轮和时间堆

Linux提供了三种定时方法:
* socket选项SO_RCVTIMEO和SO_SNDTIMEO
* SIGALRM信号
* I/O复用系统调用的超时参数

<a id="markdown-2-so_rcvtimeo和so_sndtimeo" name="2-so_rcvtimeo和so_sndtimeo"></a>
# 2. SO_RCVTIMEO和SO_SNDTIMEO

它们分别用来设置socket接收数据超时时间和发送数据超时时间,因此这两个选项仅对与数据接收和发送相关的socket专用系统调用有效

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_172550.png)

<a id="markdown-3-sigalrm信号" name="3-sigalrm信号"></a>
# 3. SIGALRM信号

由alarm和`setitimer`函数设置的实时闹钟一旦超时,将触发SIGALRM信号.因此,我们可以利用该信号的信号处理函数来处理定时任务

* https://linux.die.net/man/2/setitimer


<a id="markdown-31-基于升序链表的定时器" name="31-基于升序链表的定时器"></a>
## 3.1. 基于升序链表的定时器
添加定时器的时间复杂度是O(n),删除定时器的事件复杂度是O(1),执行定时任务的事件复杂度是O(1)


<a id="markdown-311-处理非活动连接" name="311-处理非活动连接"></a>
### 3.1.1. 处理非活动连接
Linux在内核中提供了对连接是否出于活动状态的定期检查机制,我们可以通过socket选项KEEPALIVE来激活它,不过使用这种方式将使得应用程序对连接的管理变得复杂,因此我们可以考虑在应用层实现类似于KEEPALIVE的机制,以管理所有长事件处于非活动状态的连接

* https://github.com/yqsy/linux_socket_test/blob/master/list_timer.cpp

还是使用Linux操作系统提供的`alarm`,定时将`SIGALRM`,`SIGTERM`信号以管道的方式发送给epoll 循环(避免了中断的问题,哈),当timer超时时,统一处理所有的连接的到时事件(当然每个连接都有自己的超时事件,给连接增加存活时间)

我觉得缺点

* 所有连接的时钟事件都统一依赖于`SIGALRM`这个事件了,没法做到基于连接的准确的时间点事件
* 接口比较复杂,例如用到管道`socketpair`,timer超时时统一的处理函数,以及收到连接的信息时延长时间

<a id="markdown-4-io复用系统调用的超时参数" name="4-io复用系统调用的超时参数"></a>
# 4. I/O复用系统调用的超时参数
Linux下3组I/O复用系统调用都带有超时参数,因此它们不仅能统一处理信号和I/O事件,也能统一处理定时时间.

<a id="markdown-5-高性能定时器" name="5-高性能定时器"></a>
# 5. 高性能定时器

<a id="markdown-51-时间轮" name="51-时间轮"></a>
## 5.1. 时间轮

<a id="markdown-52-时间堆" name="52-时间堆"></a>
## 5.2. 时间堆
