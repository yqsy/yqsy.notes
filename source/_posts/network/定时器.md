---
title: 定时器
date: 2017-11-10 22:15:44
categories: [网络相关]
---

<!-- TOC -->

- [1. 简介](#1-简介)
- [2. SO_RCVTIMEO和SO_SNDTIMEO](#2-so_rcvtimeo和so_sndtimeo)
- [3. SIGALRM信号](#3-sigalrm信号)
    - [3.1. 基于升序链表的定时器](#31-基于升序链表的定时器)
        - [3.1.1. 处理非活动连接](#311-处理非活动连接)
- [4. I/O复用系统调用的超时参数](#4-io复用系统调用的超时参数)
- [5. 高性能定时器](#5-高性能定时器)
    - [5.1. 时间轮](#51-时间轮)
    - [5.2. 时间堆](#52-时间堆)

<!-- /TOC -->

<a id="markdown-1-简介" name="1-简介"></a>
# 1. 简介

网络程序需要处理的第三类事件是定时事件,比如定期检测一个客户连接的活动状态.

有两种高效的管理定时器的容器:时间轮和时间堆

Linux提供了三种定时方法:
* socket选项SO_RCVTIMEO和SO_SNDTIMEO
* SIGALRM信号
* I/O复用系统调用的超时参数

<a id="markdown-2-so_rcvtimeo和so_sndtimeo" name="2-so_rcvtimeo和so_sndtimeo"></a>
# 2. SO_RCVTIMEO和SO_SNDTIMEO

它们分别用来设置socket接收数据超时时间和发送数据超时时间,因此这两个选项仅对与数据接收和发送相关的socket专用系统调用有效

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171110_172550.png)

<a id="markdown-3-sigalrm信号" name="3-sigalrm信号"></a>
# 3. SIGALRM信号

由alarm和`setitimer`函数设置的实时闹钟一旦超时,将触发SIGALRM信号.因此,我们可以利用该信号的信号处理函数来处理定时任务

* https://linux.die.net/man/2/setitimer


<a id="markdown-31-基于升序链表的定时器" name="31-基于升序链表的定时器"></a>
## 3.1. 基于升序链表的定时器
添加定时器的时间复杂度是O(n),删除定时器的事件复杂度是O(1),执行定时任务的事件复杂度是O(1)


<a id="markdown-311-处理非活动连接" name="311-处理非活动连接"></a>
### 3.1.1. 处理非活动连接
Linux在内核中提供了对连接是否出于活动状态的定期检查机制,我们可以通过socket选项KEEPALIVE来激活它,不过使用这种方式将使得应用程序对连接的管理变得复杂,因此我们可以考虑在应用层实现类似于KEEPALIVE的机制,以管理所有长事件处于非活动状态的连接

* https://github.com/yqsy/linux_socket_test/blob/master/list_timer.cpp

还是使用Linux操作系统提供的`alarm`,定时将`SIGALRM`,`SIGTERM`信号以管道的方式发送给epoll 循环(避免了中断的问题,哈),当timer超时时,统一处理所有的连接的到时事件(当然每个连接都有自己的超时事件,给连接增加存活时间)

我觉得缺点是
* 以固定的频率调用心搏函数tick,并在其中依次检测到期的定时器,然后执行到期定时器上的回调函数,定时不精确
* 插入定时器越多,效率就越差
* 接口比较复杂,例如用到管道`socketpair`,timer超时时统一的处理函数,以及收到连接的信息时延长时间

<a id="markdown-4-io复用系统调用的超时参数" name="4-io复用系统调用的超时参数"></a>
# 4. I/O复用系统调用的超时参数
Linux下3组I/O复用系统调用都带有超时参数,因此它们不仅能统一处理信号和I/O事件,也能统一处理定时时间.

<a id="markdown-5-高性能定时器" name="5-高性能定时器"></a>
# 5. 高性能定时器

<a id="markdown-51-时间轮" name="51-时间轮"></a>
## 5.1. 时间轮
添加定时器的时间复杂度是O(1),删除定时器的事件复杂度是O(1),执行定时任务的事件复杂度是O(n)

实际上执行一个定时器任务的效率要比O(n)要好的多,因为时间轮将所有的定时器散列到了不同的链表上.事件轮的槽越多,等价于散列表的入口(entry)越多,从而每条链表上的定时器数量越少.


ts = (cs + (ti/si)) % N

* https://github.com/yqsy/linux_socket_test/blob/master/wheel_timer.h

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171112_194842.png)

* 要提高时间轮的精度,就要使si (slot interval)足够小
* 要提高执行效率则要使N足够大

<a id="markdown-52-时间堆" name="52-时间堆"></a>
## 5.2. 时间堆
添加一个定时器的时间复杂度是O(lgn),删除一个定时器的时间复杂度是O(1),执行一个定时器的事件复杂度是O(1).时间堆的效率是很高的.

设计定时器的另外一个思路是: 将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔,这样,一旦心搏函数tick被调用,超时时间最小的定时器必然到期,我们就可以在tick函数中处理该定时器.然后,再次从剩余的定时器中找出超时事件最小的一个,并将这段最小时间设置为下一次心搏间隔.如此反复,就实现了较为精确的定时.

最小堆很适合处理这种定时方案,最小堆是指每个节点的指都小于或等于其子节点的值的完全二叉树.

* https://github.com/yqsy/linux_socket_test/blob/master/min_heap_timer.h

我的疑问:
* 例如当前的最小定时器超时时间为30s,在这30s中,加入了15s的定时器,那会如何?
* 数据结构用优先级队列呢?
* asio / libev / libevent / muduo 这些库用什么方案?
