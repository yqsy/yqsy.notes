---
title: 多进程编程
date: 2017-11-18 22:58:21
categories: [网络相关]
---

<!-- TOC -->

- [1. 管道](#1-管道)
- [2. 信号量](#2-信号量)
- [3. 共享内存](#3-共享内存)
- [4. 消息队列](#4-消息队列)

<!-- /TOC -->

<a id="markdown-1-管道" name="1-管道"></a>
# 1. 管道

如果要实现父,子进程之间的双向数据传输,就必须使用两个管道,socket编程接口提供了一个创建全双工管道的系统掉哦要你管: `socketpair`.

squid服务器程序就是利用socketpair创建管道,以实现在父进程和日志服务子进程之间传递日志信息

例如 https://github.com/yqsy/linux_socket_test/blob/master/list_timer.cpp,  
信号不能直接发送给epoll,所以通过双向管道发送给管道一端,管道另一端为epoll.  
达到在event loop(io事件,信号,定时器)统一处理的目的
```c++
    setnonblocking(pipefd[1]); // 管道[1]用来接收 14 时钟 15 退出 信号
    addfd(epollfd, pipefd[0]); // 管道[0]绑定在epoll上
```

资料:
* https://linux.die.net/man/3/socketpair

<a id="markdown-2-信号量" name="2-信号量"></a>
# 2. 信号量


类似Windows信号量,用的不多,暂时不研究

* semget: 创建一个新的信号量集,或者获取一个已经存在的信号量集
* semop: 改变信号量的值,即改变P,V的值
* semctl: 允许调用者对信号量进行直接控制

资料:
* https://linux.die.net/man/7/sem_overview
* https://www.zhihu.com/question/47411729

<a id="markdown-3-共享内存" name="3-共享内存"></a>
# 3. 共享内存

`最高效的IPC机制`,因为它不涉及进程之间的任何数据传输,这种高效率带来的问题是,我们必须用其他辅助手段来同步进程对共享内存的访问,否则会产生竞态条件.因此,共享内存通常和其他进程间通信方式一起使用.


* shmget: 创建一段新的共享内存,或者获取一段已经存在的共享内存
* shmat: 关联到进程的地址空间中
* shmdt: 从进程地址空间中分离
* shmctl: 控制共享

资料:
* https://linux.die.net/man/7/shm_overview

<a id="markdown-4-消息队列" name="4-消息队列"></a>
# 4. 消息队列

消息队列是两个进程之间传递二进制块数据的一种简单有效的方式,每个数据块都有一个特定的类型,接收方可以根据类型来有选择地接收数据,而不一定像管道和命名管道那样必须以先进先出的方式接收数据

* msgget: 创建一个消息队列,或者获取一个已有的消息队列
* msgsnd: 把一条消息添加到消息队列中
* msgrcv: 从消息队列中获取数据
* msgctl: 控制消息队列的某些属性

资料:
* https://linux.die.net/man/7/mq_overview
