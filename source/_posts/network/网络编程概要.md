---
title: 网络编程概要
date: 2018-05-03 10:41:50
categories: [网络相关]
---


<!-- TOC -->

- [1. 应用层程序员注意哪些](#1-应用层程序员注意哪些)
- [2. 使用TCP传输可以多快](#2-使用tcp传输可以多快)
- [3. 关注哪些性能指标](#3-关注哪些性能指标)
- [4. 每个连接占用多少资源](#4-每个连接占用多少资源)
- [5. 最大多少连接](#5-最大多少连接)
- [6. 使用tcp要做的3个事情](#6-使用tcp要做的3个事情)
- [7. 正确关闭连接](#7-正确关闭连接)
- [8. 心跳包怎么做](#8-心跳包怎么做)
- [9. 流分包的手段](#9-流分包的手段)
- [10. 应用层缓冲区是必须的](#10-应用层缓冲区是必须的)
- [11. 最大连接数限制](#11-最大连接数限制)

<!-- /TOC -->

<a id="markdown-1-应用层程序员注意哪些" name="1-应用层程序员注意哪些"></a>
# 1. 应用层程序员注意哪些

* Etnernet framse 以太网: 帧
* IP packet : 分组 (不是分片)
* TCP segment: 分节
* Application message: 消息


<a id="markdown-2-使用tcp传输可以多快" name="2-使用tcp传输可以多快"></a>
# 2. 使用TCP传输可以多快

* https://en.wikipedia.org/wiki/Data_rate_units (单位参考)
* https://en.wikipedia.org/wiki/Ethernet_frame (enthernet)
* https://en.wikipedia.org/wiki/IPv4 (ipv4)
* https://en.wikipedia.org/wiki/Transmission_Control_Protocol (tcp)

包头大小:
* Ethernet frame(without option) - 38B
* ipv4 header (without option) - 20B
* tcp header (without option) - 20B
* tcp option - 12B

1Gb Ethernet 带宽是多少? 125(MB/s) = 125,000,000(B/s) (Raw bandwidth)

Ethernet payload: 46-1500(B) 加上header: 84-1538(B)

每秒能传多少包?
* 每次都传输最小的包: 125,000,000 / 84 = 1,488,000 (packet/s)
* 每次都传输最大的包: 125,000,000 / 1538 = 81,274 (packet/s)

1Gb Ethernet下tcp最大吞吐量:
* 81,274 * (1500 - 52) = 117,684,752 = 117MB/S 或 112MiB/S

<a id="markdown-3-关注哪些性能指标" name="3-关注哪些性能指标"></a>
# 3. 关注哪些性能指标

* Bandwidth带宽, MB/s
* Throughput吞吐量, messages/s,queries/s(QPS),transactions/s(TPS)
* Latency延迟
* 资源使用率
* cpu使用率

<a id="markdown-4-每个连接占用多少资源" name="4-每个连接占用多少资源"></a>
# 4. 每个连接占用多少资源

* https://zhuanlan.zhihu.com/p/25241630


<a id="markdown-5-最大多少连接" name="5-最大多少连接"></a>
# 5. 最大多少连接

* https://www.zhihu.com/question/66553828
* https://blog.csdn.net/solstice/article/details/6579232

<a id="markdown-6-使用tcp要做的3个事情" name="6-使用tcp要做的3个事情"></a>
# 6. 使用tcp要做的3个事情

* SO_REUSEADDR,监听复用地址
* 禁用SIGPIPE,防止收到客户端的关闭事件使服务端关闭
* 禁用Nagle算法,防止请求应答的延迟

<a id="markdown-7-正确关闭连接" name="7-正确关闭连接"></a>
# 7. 正确关闭连接

作为proxy,a->proxy->b:  
* 传透a->proxy->b的半关闭
* 传透a<-proxy<-b的半关闭
* close fd

client,server:  
* 协议设计的好,两边明确收发完所有消息,随便关闭
* 客户端主动FIN,服务端检查有没有数据需要发送.如果发送完毕,shutdown write,close
* 服务端发完数据后主动shutdown write,read 返回0, close

<a id="markdown-8-心跳包怎么做" name="8-心跳包怎么做"></a>
# 8. 心跳包怎么做

* https://www.zhihu.com/question/35896874/answer/116301692

为什么无法用keeplive代替心跳包?
* 负载均衡设备或代理无法穿透SO_KEEPLIVE
* 进程死锁,或阻塞,操作系统也能正常收发 SO_KEEPLIVE,无法说明应用程序还能正常工作

实现心跳包的思路?
* 发送周期
* 检查周期
* timeout

避免误报timeout取为2个检查周期(网络消息延时波动,定时器波动)`如果最近的心跳消息的接收时间早于now - 2Tc,可判断心跳失效`

还有消息堆积而产生假心跳的问题,可以把判断规则改成`如果最近的心跳消息的发送时间早于now - 2Tc,可判断心跳失效`

`受闰秒影响,Tc不要小于1s`

* 要在工作线程中发送,`不要单独起一个心跳线程` (工作线程死锁,还继续发心跳)
* 与业务消息用同一个连接,不`要单独用心跳连接` (防火墙在tcp没有数据交互时判断连接已关闭)

<a id="markdown-9-流分包的手段" name="9-流分包的手段"></a>
# 9. 流分包的手段

* 固定长度,例如roundtrip
* 特殊的字符边界,例如\r\n
* 头部加长度字段
* 利用消息格式本身来分包
 
 参考:
 * https://github.com/yqsy/recipes/tree/master/codec
 
<a id="markdown-10-应用层缓冲区是必须的" name="10-应用层缓冲区是必须的"></a>
# 10. 应用层缓冲区是必须的

其实不论阻塞非阻塞,应用层缓冲区都是必须的.

例如读: 协议为\r\n末尾时,难道从内核缓冲区一次拷贝一个字节判断是否是\r\n吗?要多少次系统调用!肯定是准备一个足够大的缓冲区一次尽可能的读到应用层  
例如写: 准备一大块数据调用系统接口send,在send拷贝到内核缓冲区之前,这块数据库不能被修改,只能在末尾append,这也就是写缓冲区


<a id="markdown-11-最大连接数限制" name="11-最大连接数限制"></a>
# 11. 最大连接数限制

描述符满了怎么做?  
继续accept或者connect会怎么样?  
怎么限制并发连接数  

* https://github.com/yqsy/recipes/tree/master/maxconnection
* https://golang.org/src/net/http/server.go (accept满了的做法,参考Serve函数)


