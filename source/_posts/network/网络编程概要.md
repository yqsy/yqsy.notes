---
title: 网络编程概要
date: 2017-11-07 20:15:44
categories: [网络相关]
---

<!-- TOC -->

- [1. 概要](#1-概要)
- [2. 测试吞吐量的方法](#2-测试吞吐量的方法)
    - [2.1. 理论](#21-理论)
    - [2.2. 实际](#22-实际)
- [3. 例子](#3-例子)
- [4. What performance do we care](#4-what-performance-do-we-care)
- [5. 每个连接占用多少字节](#5-每个连接占用多少字节)
- [6. 正确关闭连接](#6-正确关闭连接)
- [7. tcp启动三部曲](#7-tcp启动三部曲)
    - [7.1. SO_REUSEADDR](#71-so_reuseaddr)
    - [7.2. SIGPIPE](#72-sigpipe)
    - [7.3. Nagle算法](#73-nagle算法)
- [8. 非阻塞I/O会碰到的问题](#8-非阻塞io会碰到的问题)
- [9. TCP 最大多少链接?](#9-tcp-最大多少链接)
- [10. 心跳包设计](#10-心跳包设计)

<!-- /TOC -->


<a id="markdown-1-概要" name="1-概要"></a>
# 1. 概要

应用层程序员只需要关注4层:

* Etnernet framse 以太网: 帧
* IP packet : 分组 (不是分片)
* TCP segment: 分节
* Application message: 消息

<a id="markdown-2-测试吞吐量的方法" name="2-测试吞吐量的方法"></a>
# 2. 测试吞吐量的方法

```bash
# 主机监听
nc -l 5001 > /dev/null

# 显示进度条(显示的是MiB)
nc -l 5001 | pv -W > /dev/null

# 向主机发送
dd if=/dev/zero bs=1MB count=1000 | nc 192.168.2.153 5001
```

<a id="markdown-21-理论" name="21-理论"></a>
## 2.1. 理论

* https://en.wikipedia.org/wiki/Data_rate_units

关于K M G的算法是使用二进制还是十进制

领域|计算方式
-|-
计算机数据传送速度|十进制
硬盘生产商|十进制
操作系统|二进制

1Gb Ethernet: 1Gb/s = 125MB/s = 125,000,000B/s (Raw bandwidth)

Ethernet frame Total 84 ~ 1538 B

字段|长度
-|-
Preamble|7 B
Start of frame delimiter|1 B
MAC destination|6 B
MAC source|6 B
Ethertype|2 B
Payload|46-1500 B
CRC|4 B
Gap|12 B

Packet per second

* Max 125,000,000 / 84 = 1,488,000
* Min 125,000,000 / 1538 = 81,274

TCP/IP overhead
* IP header 20B
* TCP header 20B
* TCP option 12B

Max TCP throughput:
* 81,274 * (1500 - 52) = 117,684,752 = 117MB/S 或 112Mib/S

所以千兆带宽使用TCP传输数据的速度是117MB/S,百兆带宽是11.7MB/S

<a id="markdown-22-实际" name="22-实际"></a>
## 2.2. 实际
树莓派向虚拟机发送1G  
1000000000 bytes (1.0 GB) copied, 85.0122 s, 11.8 MB/s  (百兆网卡)

虚拟机向自己发送10G  
10000000000 bytes (10 GB) copied, 12.2552 s, 816 MB/s  
![](http://ouxarji35.bkt.clouddn.com/snipaste_20171125_093510.png)

<a id="markdown-3-例子" name="3-例子"></a>
# 3. 例子

Basic,non-concurrent examples
* TTCP: classic TCP performance testing  tool
* Round-trip: measure clock error bwtween two hosts (udp)
* Netcat: a Swiss knife
* procmon
* Slow sink/source (慢速收发工具)

Concurrent examples
* SOCKS proxy server
* Sudoku solver
* Simple memcached
* Broadcasting to multiple TCP peers

Data processing with multiple machines (hadoop或spark现成)
* Parallel N-queues
* Median of numbers accross machines
* Frequent queries (找出日志最频繁的查询)
* Distributed sorting (分布式排序 (MapReduce))

Advanced topics
* RPC - A basic building block for various servers
* Load balancing (Better than round-robin)
* Capacity of a serving system (How many machines do i need to support X QPS?)
* Fight for latency (测延时)

<a id="markdown-4-what-performance-do-we-care" name="4-what-performance-do-we-care"></a>
# 4. What performance do we care

* Bandwidth, MB/s
* Throughput, messages/s,queries/s(QPS),transactions/s(TPS)
* Latency,milliseconds,percentiles
* Utilization, percent, payload (资源使用率)vs. carrier,goodputs vs. theory BW
* Overhead(额外开销), eg. CPU usage, for compression and/or encryption


<a id="markdown-5-每个连接占用多少字节" name="5-每个连接占用多少字节"></a>
# 5. 每个连接占用多少字节

* https://zhuanlan.zhihu.com/p/25241630


<a id="markdown-6-正确关闭连接" name="6-正确关闭连接"></a>
# 6. 正确关闭连接

netcat的作用
* nc < /dev/zero  chargen
* nc > /dev/null  discard
* dd /dev/zero | nc    poor man's ttcp
* nc < file, nc > file poor man's scp


难度
* 建立TCP连接 < 销毁TCP连接
* 服务器建立连接 < 客户端建立连接
* 接收TCP数据 < 发送TCP数据难度 (非阻塞I/O)



close不能太早,自己接收缓冲区还有数据未接收,你直接调用close会发送RST分节,强行断开连接.造成对方收不全数据.

SO_LINGER无助解决问题

SO_LINGER:  
https://stackoverflow.com/questions/3757289/tcp-option-so-linger-zero-when-its-required


错误使用TCP的例子,认为TCP不可靠  
当接收缓冲区中有数据时,程序直接调用close,会使tcp协议栈直接发送reset分节,强行关闭连接.发送缓冲区的数据会被丢掉.  
https://blog.netherlabs.nl/articles/2009/01/18/the-ultimate-so_linger-page-or-why-is-my-tcp-not-reliable

正确方法: 

read返回0(End of file) 调用close

* correct sender: send() + shutdown(WR) + read() -> 0 close()
* correct receive: read() -> 0 + if nothing more to send + close()

read返回0就close其实也有问题  
如何正确关闭 tcp 连接？ - 胡宇光的回答 - 知乎  
https://www.zhihu.com/question/48871684/answer/113135138  

(恶意/有bug客户端) 客户端不close()  
产品代码中,一段时间后没有close主动关闭连接  

其实上面的是对于协议没有明确到有多长,如果像ttcp明确有多长了,客户端可以直接close.接收方主动得知数据有多长  

为什么客户端可以直接close?
客户端已经收到想要的数据了,通讯完毕了,直接close(其实这时也要考虑有没有向服务端发送的数据,服务端是否已经收到)

注意安全:

客户端不close,使连接一直处在FIN_WAIT_2.需要使用定时器把shut_down指定时间之内客户端不发送close过来的连接关闭掉


<a id="markdown-7-tcp启动三部曲" name="7-tcp启动三部曲"></a>
# 7. tcp启动三部曲

<a id="markdown-71-so_reuseaddr" name="71-so_reuseaddr"></a>
## 7.1. SO_REUSEADDR

TCP server can restart immediately after crash/kill

<a id="markdown-72-sigpipe" name="72-sigpipe"></a>
## 7.2. SIGPIPE

程序向已经关闭的管道发送数据会收到SIGPIPE信号,默认行为是终止进程

在UNIX场景中有用,管道末端的程序退出了,那么一串程序都会收到SIGPIPE信号.要死一起死,不做多余计算,浪费CPU资源.
```
gunzip -c huge.log.gz | grep ERROR | head
```

在旧时代可以起到节流的作用,但是到了网络时代,服务端一旦收到客户端的关闭事件,`就会触发到SIGPIPE,关闭,算是一个严重的BUG`

<a id="markdown-73-nagle算法" name="73-nagle算法"></a>
## 7.3. Nagle算法

* https://en.wikipedia.org/wiki/Nagle%27s_algorithm
* http://localhost:8080/source/xref/recipes/tpc/bin/nodelay.cc

作用是防止发的大量的数据包太小会造成网络负担大,不过副作用是影响到请求应答的延迟

默认情况下要关闭,go语言默认就是关闭的


<a id="markdown-8-非阻塞io会碰到的问题" name="8-非阻塞io会碰到的问题"></a>
# 8. 非阻塞I/O会碰到的问题

* 读: 应用层读缓冲区,没问题
* 写: 缓冲区不为空,不能调用write,会造成乱序.一定要追加到缓冲区末尾
  * 一般的做法是判断缓冲区为空,直接write,缓冲区不为空,追加到缓冲区
  * 保守的做法是全部塞到缓冲区
  * 发完了缓冲区的数据时,要关闭监视POLLOUT事件.(shutwrite) 不关闭监视事件会发生busy loop

写可以看muduo的
`  void TcpConnection::sendInLoop(const void* data, size_t len)`

* 带宽不匹配(阻塞型I/O的好处会自己节流限速)

要设置一个high-water mark, low-water mark.当到了高水位,停止发.到了低水位,开始发.



<a id="markdown-9-tcp-最大多少链接" name="9-tcp-最大多少链接"></a>
# 9. TCP 最大多少链接?

* https://www.zhihu.com/question/66553828
* http://blog.csdn.net/solstice/article/details/6579232


五元组:  
服务器IP + 服务器端口 + TCP + 客户端IP + 客户端端口

<a id="markdown-10-心跳包设计" name="10-心跳包设计"></a>
# 10. 心跳包设计

* https://www.zhihu.com/question/35896874/answer/116301692
* https://felixge.de/2014/08/26/tcp-keepalive-with-golang.html (go keeplive使用方法)

---
* 负载均衡设备或代理无法穿透SO_KEEPLIVE
* 进程死锁,或阻塞,操作系统也能正常收发 SO_KEEPLIVE,无法说明应用程序还能正常工作

具体实现需要:
* 发送周期
* 检查周期
* timeout

避免误报timeout取为2个检查周期(网络消息延时波动,定时器波动)`如果最近的心跳消息的接收时间早于now - 2Tc,可判断心跳失效`

还有消息堆积而产生假心跳的问题,可以把判断规则改成`如果最近的心跳消息的发送时间早于now - 2Tc,可判断心跳失效`

`受闰秒影响,Tc不要小于1s`

* 要在工作线程中发送,`不要单独起一个心跳线程` (工作线程死锁,还继续发心跳)
* 与业务消息用同一个连接,不`要单独用心跳连接` (防火墙在tcp没有数据交互时判断连接已关闭)

