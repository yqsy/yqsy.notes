---
title: 分布式系统全局唯一号
date: 2018-07-01 15:43:39
categories: [微服务]
---

<!-- TOC -->

- [1. 唯一序号](#1-唯一序号)
- [2. 唯一进程号码](#2-唯一进程号码)

<!-- /TOC -->




<a id="markdown-1-唯一序号" name="1-唯一序号"></a>
# 1. 唯一序号

* https://zhuanlan.zhihu.com/p/32657546 
* https://www.cnblogs.com/baiwa/p/5318432.html

(1) 利用数据库递增,全数据库唯一
* 优点: 明显,可控
* 缺点: 单库单表,数据库压力大

(2) length=32的16进制格式的字符串,如果回退为byte数组共16个byte元素,则是表示128bit长的数字
* 优点: 对数据库压力减轻了
* 缺点: 排序怎么办?

(3) twitter开发了一套全局唯一ID生成服务Snowflake
* 41位的时间序列 (精确到毫秒,41位的长度可以使用69年)
* 10位的机器表示 (10位的长度最多支持部署1024个节点)
* 12位的计数顺序号(每个节点每毫秒产生4096个ID序号)

方案优缺点:
* 优点: 高性能,低延迟,独立的应用,按时间有序
* 缺点: 需要独立的开发和部署

(4) redis生成的ID

因为redis是单线程的,可以使用redis的原子操作INCR和NCRBY来实现,如果使用集群,假设有5台,可以这样来:

A：1,6,11,16,21  
B：2,7,12,17,22  
C：3,8,13,18,23  
D：4,9,14,19,24  
E：5,10,15,20,25  

适合生成每天从零开始的流水号,比如订单号=日期+当日自增长号.可以每天在redis生成一个key,使用INCR来增加

优点: 
* 不依赖于数据库,灵活方便,且性能优于数据库
* 数字ID天然排序,对分页或者需要排序的结果有帮助
* 使用redis集群可以防止单点故障的问题

缺点:
* 如果系统中没有Redis,还要引入redis,增加系统复杂度
* 需要编码和配置的工作量比较大,多运维环境很麻烦
* 程序实例负载到哪一个redis一旦确定好,未来很难做修改

(5) Flicker的解决方案
借助mysql的auto_increment + replace info + MyISAM

优点: 充分借助数据库的自增ID,机制,提高可靠性,生成的ID有序
缺点: 占用两个独立的mysql实例,浪费资源


<a id="markdown-2-唯一进程号码" name="2-唯一进程号码"></a>
# 2. 唯一进程号码

* https://blog.csdn.net/Solstice/article/details/6285216


如果使用ip:port,问题:
* 如何得知程序是前世还是今生

如果使用ip:port:pid,问题:
* pid的空间非常的小,可能会在轮回后重复

如果使用全局gpid分配服务,问题:
* 如何保证分配的id不重复,它可能也会重启?
* 单点故障
* 容错,状态迁移?

正确做法:

四元组: ip:port:start_time:pid
* 容易保证唯一性. 1. 短时间重启,pid不重复 2.长时间重启,两次start_time不重复
* 产生的成本低
* gpid有意义,能够知道是哪台机器,什么时间启动,在/proc/的位置

其他:

仅仅以 ip:port:start_time 作为进程号码,则不能保证唯一性,因为程序短时间重启,系统时间会跳变(ntp调整时间或闰秒)

