---
title: 算法的乐趣
date: 2017-12-3 16:07:31
categories: [读书笔记]
---

<!-- TOC -->

- [1. p9-为什么会对数学不感兴趣](#1-p9-为什么会对数学不感兴趣)
- [2. p9-认识到数学的价值](#2-p9-认识到数学的价值)
- [3. p12-朴素贝叶斯分类解决的问题](#3-p12-朴素贝叶斯分类解决的问题)
- [4. p14-算法在生活中的应用](#4-p14-算法在生活中的应用)
- [5. p20-什么是算法?](#5-p20-什么是算法)
- [6. p22-环形队列解决的问题](#6-p22-环形队列解决的问题)
- [7. p28-兴趣是最好的老师以及算法乐趣的三个层次](#7-p28-兴趣是最好的老师以及算法乐趣的三个层次)
- [8. p40-基本数据结构在算法设计中的应用](#8-p40-基本数据结构在算法设计中的应用)
    - [8.1. 线性表](#81-线性表)
        - [8.1.1. 数组](#811-数组)
        - [8.1.2. 链表](#812-链表)
        - [8.1.3. 栈](#813-栈)
        - [8.1.4. 队列](#814-队列)
- [9. p43-复杂数据结构在算法设计中的应用](#9-p43-复杂数据结构在算法设计中的应用)
    - [9.1. 树](#91-树)
        - [9.1.1. 二叉查找树](#911-二叉查找树)
        - [9.1.2. 自平衡二叉树](#912-自平衡二叉树)
    - [9.2. 集合](#92-集合)
    - [9.3. 哈希表与映射](#93-哈希表与映射)
    - [9.4. 图](#94-图)
- [10. p55-算法设计的常用思想](#10-p55-算法设计的常用思想)
    - [10.1. 贪婪法](#101-贪婪法)
        - [10.1.1. 贪婪法的基本思想](#1011-贪婪法的基本思想)
        - [10.1.2. 硬币找钱的例子](#1012-硬币找钱的例子)
        - [10.1.3. 贪婪法得不到最优解](#1013-贪婪法得不到最优解)
        - [10.1.4. -1背包问题](#1014--1背包问题)
    - [10.2. p61-分治法](#102-p61-分治法)
        - [10.2.1. 分治法的基本思想](#1021-分治法的基本思想)
    - [10.3. p66-动态规划](#103-p66-动态规划)
        - [10.3.1. 动态规划的基本思想](#1031-动态规划的基本思想)
    - [10.4. p74-穷举法](#104-p74-穷举法)
        - [10.4.1. 穷举解空间的策略](#1041-穷举解空间的策略)

<!-- /TOC -->

<a id="markdown-1-p9-为什么会对数学不感兴趣" name="1-p9-为什么会对数学不感兴趣"></a>
# 1. p9-为什么会对数学不感兴趣
说到乐趣，总让我想起我学习和使用数学知识的经历。虽然我的学位是关于统计机器学习的，而且毕业后一直从事相关工作，**但是我从小学一年级到博士第三年都对数学毫无兴趣，因为学校的老师和数学成绩好的同学都说不明白数学的用处，以至于我一直以为数学的作用只是锻炼和展示自己的聪明，博得老师的表扬，成为陈景润那样为国争光的英雄**。而这些对我实在没有吸引力，而且我认为恐怕对绝大部分学生都没什么吸引力。

<a id="markdown-2-p9-认识到数学的价值" name="2-p9-认识到数学的价值"></a>
# 2. p9-认识到数学的价值
我认识到数学的价值，是因为在博士第三年把研究方向换到了统计机器学习。在读教材的时候，我曾想验证“数学无用”，所以费尽心力地试图写一个程序来判断一个64×64像素的图片里到底是数字“1”还是数字“9”，却发现无论如何也很难写一个有效的程序；**可是利用教材里的数学知识却能设计和“训练”一个数学模型，准确地识别任意字符。因为体会到了数学的用处，我兴奋地用了一年的时间复习大学本科的数学课程，然后才读懂了人工智能的专业教材和论文。此后才有所创新，发表论文，到博士毕业。这整个过程用了三年，而效果超过了之前19年数学教育的效果。**

ps:体会到了乐趣,用处,才会全身心的投入,三年的投入比十九年的教育的效果来的更有意义.

<a id="markdown-3-p12-朴素贝叶斯分类解决的问题" name="3-p12-朴素贝叶斯分类解决的问题"></a>
# 3. p12-朴素贝叶斯分类解决的问题
有一次我们发布了一个APP，在注册时要求用户输入自己的真实姓名，但是粗心的工程师忘记了要求用户填写自己的性别，更可怜的是在欢迎页上面明晃晃地写着“欢迎XXX先生注册XX网”，可是应用已经发布到了App Store，到底怎么办？有一位工程师提出了一个办法，我们根据已有的用户姓名和性别作为训练集，来预测新用户到底是男还是女，为了让这个错误尽快得到修复，**我们使用了最简单的朴素贝叶斯分类算法，最终测试集上的预测准确率达到93%，也就是说我们解决了93%用户的体验问题。我把这类算法称为专业类算法**，也就是招聘网站上算法工程师要求的算法，例如图像处理工程师、数据挖掘工程师等。


<a id="markdown-4-p14-算法在生活中的应用" name="4-p14-算法在生活中的应用"></a>
# 4. p14-算法在生活中的应用
如果你想设计一个“狡猾”的程序，那么本书中的**搜索剪枝、A*寻径、博弈树以及遗传算法**等将给你带来启发。**快速傅里叶变换**，这么霸气而又高大上的名字，其实在我们生活中的应用随处可见，**家中的Wi-Fi、智能手机、电话、路由器等几乎所有内置计算机系统的东西都会以各种方式使用这个算法**。RLE数据压缩算法，在文档、视频、音乐、数据存储、云计算、数据库等几乎所有应用中都有着广泛的运用。压缩算法令系统更有效，成本更低。再来说密码学算法中非常重要的RSA算法，如果没有这些算法，互联网就会变得不安全，电子交易就不会如此可信。

好玩的算法还有很多很多，**历法与二十四节气的计算、华容道、井字棋、黑白棋、五子棋以及俄罗斯方块**……你会惊讶地发现，再简单不过的事情背后，都藏着算法的神奇背影。不妨将本书放在案头慢慢品读，你将能看到算法如何深入我们的日常生活，如何重塑我们的世界


<a id="markdown-5-p20-什么是算法" name="5-p20-什么是算法"></a>
# 5. p20-什么是算法?
Weiss在《数据结构与算法分析》一书中将算法描述为一系列的计算步骤，将输入数据转换成输出的结果。

定义|说明
-|-
 确定性    | 算法的每个步骤都是明确的，对结果的预期也是确定的                                                  
 有穷性    | 算法必须是由有限个步骤组成的过程，步骤的数量可能是几个，也可能是几百万个，但是必须有一个确定的结束条件                       
 可行性    | 一般来说，我们期望算法最后得出的是正确的结果，这意味着算法中的每一个步骤都是可行的。只要有一个步骤不可行，算法就是失败的，或者不能被称为某种算法  
 输入和输出  | 算法总是要解决特定的问题，问题来源就是算法的输入，期望的结果就是算法的输出。没有输入的算法是没有意义的，没有输出的算法是没有用的。         

本人将算法定义为：**算法是为解决一个特定的问题而精心设计的一套数学模型以及在这套数学模型上的一系列操作步骤，这些操作步骤将问题描述的输入数据逐步处理、转换，并最后得到一个确定的结果**


<a id="markdown-6-p22-环形队列解决的问题" name="6-p22-环形队列解决的问题"></a>
# 6. p22-环形队列解决的问题

这个方案使用一个长度为1000条记录的数组存储日志，用一个计数器记录当前写入的有效日志条数，数据结构的设计中规中矩，但是当缓冲区满，需要覆盖旧记录时遇到了麻烦，因为每次都要移动数组中的前999条记录，才能为新记录腾出空间，这将使Epon_Sync_Log_Add()函数的性能急剧恶化。考虑到这一点，小伙儿为他的方案设计了一个阈值，就是SYNC_LOG_MEMOVER_CNT常量定义的50。**当缓冲区满的时候，就一次性向前移动950条记录，腾出50条记录的空间，避免了每新增一条记录就要移动全部数据的情况。可见这个小伙儿还是动了一番脑子的.**

其实，类似这样的固定长度缓冲区的读写，环形队列通常是最好的选择。

<a id="markdown-7-p28-兴趣是最好的老师以及算法乐趣的三个层次" name="7-p28-兴趣是最好的老师以及算法乐趣的三个层次"></a>
# 7. p28-兴趣是最好的老师以及算法乐趣的三个层次
因斯坦说过：“兴趣是最好的老师。”这就是说，只要一个人对某事物产生兴趣，就会主动去学习、去研究，并在学习和研究的过程中产生愉快的情绪。

我把从算法中体会到的乐趣分成三个层次: 
  * 初级层次是找到特定的算法解决特定的实际问题，这种乐趣是解决问题后的成就感
  * 中级层次是有些算法本身就是充满乐趣的，搞明白这种算法的原理并写出算法的程序代码，能为自己今后的工作带来便利
  * 高级层次是自己设计算法解决问题，让其他人可以利用你的算法享受到初级层次的乐趣。


<a id="markdown-8-p40-基本数据结构在算法设计中的应用" name="8-p40-基本数据结构在算法设计中的应用"></a>
# 8. p40-基本数据结构在算法设计中的应用

<a id="markdown-81-线性表" name="81-线性表"></a>
## 8.1. 线性表
数组、链表、栈和队列是四种最常见的线性表

<a id="markdown-811-数组" name="811-数组"></a>
### 8.1.1. 数组
  * 所有数据元素存储在一片连续的区域内
  * 对数组的访问方式一般是通过下标直接访问数组元素
  * 对数组的基本操作还有插入、删除和查找
  * 数组元素的直接访问几乎没有开销
  * 插入和删除操作需要移动数组元素，开销比较大
  * 在插入和删除操作比较频繁的场合下，不适合使用数组
  * 在数组中查找一个元素的时间复杂度是O(n)
  * 如果数组元素是有序存储的，则使用二分查找可以将时间复杂度降为O(lgn)

<a id="markdown-812-链表" name="812-链表"></a>
### 8.1.2. 链表
  * 每个节点数据都由两个域组成,一个是存放实际数据元素的数据,另一个就是构成链式结构的指针域
  * 链表的插入和删除只需要修改指针域的指针指向即可完成
  * 访问数据元素的效率比较低，需要从链表头部向后搜索，查找操作的时间复杂度是O(n)
  * 单向链表只能在一个方向上遍历链表节点，从一个节点开始遍历到链表的尾部节点就停止
  * 双向链表可以从两个方向遍历链表节点，从一个节点开始，向前遍历到链表头部节点停止，向后遍历到链表尾部节点停止

<a id="markdown-813-栈" name="813-栈"></a>
### 8.1.3. 栈
  * 其特殊性在于只能在表的一端插入和删除数组元素
  * 遵循“后进先出”（Last In First Out）的原则管理和维护表中的数据
  * 栈的数据存储方式**可以采用数组，也可以使用链表**，分别被称为**“顺序栈”和“链式栈”**
  * 用栈的一些特性，可以将某算法的递归实现转换成非递归实现
  * 在使用穷尽搜索方法时，也会使用栈保存当前的状态

<a id="markdown-814-队列" name="814-队列"></a>
### 8.1.4. 队列
  * 普通的队列只能在表的一端插入数据，在另一端删除数据，不能在队列的其他位置插入和删除数据
  * 插入和删除动作分别被称为“入队”和“出队”
  * 能执行“入队”的一端称为“后端”（rear），能执行出队的一端称为“前端”（front）

<a id="markdown-9-p43-复杂数据结构在算法设计中的应用" name="9-p43-复杂数据结构在算法设计中的应用"></a>
# 9. p43-复杂数据结构在算法设计中的应用

<a id="markdown-91-树" name="91-树"></a>
## 9.1. 树
树（tree）是一种表达数据之间层次关系的数据结构.

  * 树的度：一个节点含有子树的个数称为该节点的度，一棵树中最大节点的度称为整棵树的度。
  * 叶节点：度为0的节点称为叶节点。
  * 根节点：没有父节点的节点就是根节点。
  * 树的高度：从根节点开始，每多一级子节点，树的层次就+1，一棵树的最大层次数就是树的高度
  * 兄弟节点：具有相同父节点的子节点互称为兄弟节点。

根据每个节点的子节点的数量，又可以将树分为二叉树和多叉树，B树就是一种典型的多叉树。

<a id="markdown-911-二叉查找树" name="911-二叉查找树"></a>
### 9.1.1. 二叉查找树
有序的二叉树也被称为二叉查找树（binary search tree）或二叉排序树（binary sort tree）。相对于普通的二叉树，二叉查找树有以下两个特点：

  * 如果左子树不为空，则左子树上所有节点的值都小于根节点的值；
  * 如果右子树不为空，则右子树上所有节点的值都大于根节点的值。

<a id="markdown-912-自平衡二叉树" name="912-自平衡二叉树"></a>
### 9.1.2. 自平衡二叉树
为了优化查找效率，就需要二叉查找树能够具有自平衡功能，保证二叉树始终是一棵平衡树。**AVL树和红黑树就是这样的自平衡二叉查找树**，二者的区别在于维持树的自平衡的方法不一样。在算法设计时，只要有条件就应该优先使用AVL树和红黑树，避免简单二叉查找树可能存在的性能问题。


<a id="markdown-92-集合" name="92-集合"></a>
## 9.2. 集合
集合（set）是具有某种特性的事物的整体，构成集合的事物或对象称作集合的元素或成员。集合内的数据元素具有以下特征。

  * 无序性：一个集合中每个元素的地位都是相同的，元素之间不存在有序关系，也没有类似树和图那样的复杂关系。
  * 互异性：一个集合中每个元素只能出现一次，也就是说，集合内没有重复的元素。
  * 确定性：集合的定义是确定的，根据这个定义可以明确判定一个对象是否属于这个集合，不存在模棱两可的情况。

<a id="markdown-93-哈希表与映射" name="93-哈希表与映射"></a>
## 9.3. 哈希表与映射
哈希表的原理是通过一个哈希函数对关键字进行某种运算，得到对应的数据元素在表中的存储位置，然后访问其值，与普通的有序表查找相比，额外的哈希处理会造成数据访问的开销，但是哈希表的查找时间是固定的，不随哈希表中数据元素的增多而变化。普通有序表的查找时间复杂度是O(lg(n ))，**随着n 的增大，查找时间也变长，当数据元素非常多的时候，哈希表的查找速度会比普通有序表快，这就是哈希表的优势。**

<a id="markdown-94-图" name="94-图"></a>
## 9.4. 图
图（graph）是一种特殊的数据组织方式，它不仅可以存储数据元素（对象），还可以存储数据元素之间的复杂关系。

图的遍历是一个非常重要的操作，一般可采用深度优先搜索和广度优先搜索两种策略。

<a id="markdown-10-p55-算法设计的常用思想" name="10-p55-算法设计的常用思想"></a>
# 10. p55-算法设计的常用思想
《算法设计》一书的作者将算法设计定义为一个这样的设计过程：从广泛的计算机应用中提出问题开始，建立在对算法设计技术理解的基础上，并最终发展成对这些问题的有效解决

<a id="markdown-101-贪婪法" name="101-贪婪法"></a>
## 10.1. 贪婪法
贪婪法（greedy algorithm），又称贪心算法，是寻找最优解问题的常用方法。这种方法模式一般将求解过程分成若干个步骤，在每个步骤都应用贪心原则，选取当前状态下最好的或最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果也是最好或最优的解。

贪婪法和动态规划法以及分治法一样，都需要对问题进行分解，定义最优解的子结构。但是，贪婪法与其他方法最大的不同在于，**贪婪法每一步选择完之后，局部最优解就确定了，不再进行回溯处理，也就是说，每一个步骤的局部最优解确定以后，就不再修改，直到算法结束。**因为不进行回溯处理，**贪婪法只在很少的情况下可以得到真正的最优解，比如最短路径问题、图的最小生成树问题。**大多数情况下，由于选择策略的“短视”，贪婪法会错过真正的最优解，得不到问题的真正答案。**但是贪婪法简单高效，省去了为找最优解可能需要的穷举操作，可以得到与最优解比较接近的近似最优解，通常作为其他算法的辅助算法使用。**

<a id="markdown-1011-贪婪法的基本思想" name="1011-贪婪法的基本思想"></a>
### 10.1.1. 贪婪法的基本思想

1.建立对问题精确描述的数学模型，包括定义最优解的模型  
2.将问题分解为一系列子问题，同时定义子问题的最优解结构  
3.应用贪心原则确定每个子问题的局部最优解，并根据最优解的模型，用子问题的局部最优解堆叠出全局最优解。

<a id="markdown-1012-硬币找钱的例子" name="1012-硬币找钱的例子"></a>
### 10.1.2. 硬币找钱的例子
假如某国发行的货币有25分、10分、5分和1分四种硬币，假如你是售货员，你要找给客户41分钱的硬币

选择的策略是贪婪策略，即在币值总和不超过41的前提下选择币值最大的那种硬币。按照这个策略，第一次选择25分的硬币一枚，第二次选择10分的硬币一枚，第三次选择5分的硬币一枚，第四次选择1分的硬币一枚，总共需要4枚硬币。

<a id="markdown-1013-贪婪法得不到最优解" name="1013-贪婪法得不到最优解"></a>
### 10.1.3. 贪婪法得不到最优解
但是很多情况下贪婪法都不能得到最优解。同样以找零钱为例，假如某国发行的货币是25分、20分、5分和1分四种硬币，这时候找41分钱的最优策略是2枚20分的硬币加一枚1分硬币共3枚硬币，但是用贪婪法得到的结果却是1枚25分硬币，三枚5分硬币和一枚1分硬币共5枚硬币

<a id="markdown-1014--1背包问题" name="1014--1背包问题"></a>
### 10.1.4. -1背包问题
有N 件物品和一个承重为C 的背包（也可定义为体积），每件物品的重量是wi，价值是pi，**求解将哪几件物品装入背包可使这些物品在重量总和不超过C 的情况下价值总和最大**。背包问题（knapsack problem）是此类组合优化的NP完全问题的统称，比如货箱装载问题、货船载物问题等，因问题最初来源于如何选择最合适的物品装在背包中而得名。这个问题隐含了一个条件，每个物品只有一件，也就是限定每件物品只能选择0个或1个，因此又被称为0-1背包问题。

常见的贪婪策略有三种

  * 第一种策略是根据物品价值选择，每次都选价值最高的物品。
  * 第二种策略是根据物品重量选择，每次都选择重量最轻的物品。
  * 第三种策略是定义一个价值密度的概念，每次选择都选价值密度最高的物品

<a id="markdown-102-p61-分治法" name="102-p61-分治法"></a>
## 10.2. p61-分治法

分治，顾名思义，分而治之。分治法（divide and conquer）也是一种解决问题的常用模式，**分治法的设计思想是将无法着手解决的大问题分解成一系列规模较小的相同问题，然后逐个解决小问题，即所谓的分而治之**。分治法产生的子问题与原始问题相同，只是规模减小，反复使用分治方法，可以使得子问题的规模不断减小，直到能够被直接求解为止。

分治法作为算法设计中一个古老的策略，在很多问题中得到了广泛的应用，比如最大、最小问题（例如在一堆形状相同的物品中找出最重或最轻的那一个），矩阵乘法、大整数乘法以及排序（例如**快速排序和归并排序**）。除此之外，这个技巧也是许多高效算法的基础，比如**快速傅里叶变换算法和Karatsuba乘法算法。**

<a id="markdown-1021-分治法的基本思想" name="1021-分治法的基本思想"></a>
### 10.2.1. 分治法的基本思想

  * 分解：将问题分解为若干个规模较小，相互独立且与原问题形式相同的子问题，确保各个子问题的解具有相同的子结构。
  * 解决：如果上一步分解得到的子问题可以解决，则解决这些子问题，否则，对每个子问题使用和上一步相同的方法再次分解，然后求解分解后的子问题，这个过程可能是一个递归的过程。
  * 合并：将上一步解决的各个子问题的解通过某种规则合并起来，得到原问题的解。

<a id="markdown-103-p66-动态规划" name="103-p66-动态规划"></a>
## 10.3. p66-动态规划
动态规划（dynamic programming）是解决多阶段决策问题常用的最优化理论，该理论由美国数学家Bellman等人在1957年提出，用于研究多阶段决策过程的优化问题。该理论提出后，立即在数学、计算机科学、经济管理和工程技术领域得到了广泛的应用，例如**最短路线、库存管理、资源分配、设备更新、排序、装载**等问题，用动态规划方法往往比朴素的方法更高效。动态规划方法的原理就是把多阶段决策过程转化为一系列的单阶段决策问题，利用各个阶段之间的递推关系，**逐个确定每个阶段的最优化决策，最终堆叠出多阶段决策的最优化决策结果。**

每种方法都有自身的局限性，动态规划法也不是万能的。动态规划适合求解多阶段（状态转换）决策问题的最优解，也可用于含有线性或非线性递推关系的最优解问题，但是这些问题都必须满足**最优化原理和子问题的“无后向性”。**

  * 最优化原理：最优化原理其实就是问题的最优子结构的性质，如果一个问题的最优子结构是不论过去状态和决策如何，对前面的决策所形成的状态而言，其后的决策必须构成最优策略。也就是说，不管之前决策是否是最优决策，都必须保证从现在开始的决策是在之前决策基础上的最优决策，则这样的最优子结构就符合最优化原理。
  * 无后向性（无后效性）：所谓“无后向性”，就是当各个阶段的子问题确定以后，对于某个特定阶段的子问题来说，它之前的各个阶段的子问题的决策只影响该阶段的决策，对该阶段之后的决策不产生影响，也就是说，每个阶段的决策仅受之前决策的影响，但是不影响之后各阶段的决策。

<a id="markdown-1031-动态规划的基本思想" name="1031-动态规划的基本思想"></a>
### 10.3.1. 动态规划的基本思想
和分治法一样，动态规划解决复杂问题的思路也是对问题进行分解，通过求解小规模的子问题再反推出原问题的结果。但是动态规划分解子问题不是简单地按照“大事化小”的方式进行的，而是沿着决策的阶段划分子问题，决策的阶段可以随时间划分，也可以随着问题的演化状态划分。**分治法要求子问题是互相独立的，以便分别求解并最终合并出原始问题的解**，**但是动态规划法的子问题不是互相独立的，子问题之间通常有包含关系，甚至两个子问题可以包含相同的子子问题。**

<a id="markdown-104-p74-穷举法" name="104-p74-穷举法"></a>
## 10.4. p74-穷举法
穷举并不是漫无目的地乱找，它是一种在有限的解空间（解空间至少在理论上是有限的）内按照一定的策略进行查找的思想。数学上也把穷举法称为枚举法，就是在一个由有限个元素构成的集合中，将所有元素一一枚举研究的方法。比如要找出一个班上身高最高的同学，只需要给这个班上的同学一一测量身高，然后通过比较就可以确定哪个同学身高最高。穷举法就是这样一种思想，对解空间内的候选解按某种顺序进行逐一枚举和检验，并根据问题给定的条件从中找出那些符合要求的候选解作为问题的解。**穷举法一般可以找出解空间中所有正确的解，如果给定最优解的判断条件，穷举法也可以用于求解最优解问题。**

一般来说，只要一个问题有其他更好的解决方法，通常不会选择穷举法，穷举法也常被作为“不是办法的办法”或“最后的办法”。

<a id="markdown-1041-穷举解空间的策略" name="1041-穷举解空间的策略"></a>
### 10.4.1. 穷举解空间的策略

1.盲目搜索算法  
广度优先搜索和深度优先搜索是两种常用的盲目搜索算法，这种搜索算法只根据问题的规模，按照广度优先和深度优先的原则搜索解空间内的每一个状态。

广度优先算法因为需要额外的存储空间，因此在设计算法时要考虑此额外空间的规模。深度优先算法在搜索过程中容易陷入状态循环，导致在一个没有解的子树上“死循环”，一般需要做状态循环的判断和避免。但总的来说，两种策略并无优劣之分，很多情况下可以互换使用。

2.启发式搜索算法  
很多情况下，当问题的规模达到一定的程度，盲目搜索算法就会因为低效而被排斥，理论上可以得到答案，但是要等一万年，这是人类不能接受的结果。如果搜索能够智能化一点，利用搜索过程中出现的额外信息直接跳过一些状态，避免盲目的、机械式的搜索，就可以加快搜索算法的收敛，这就是启发性搜索。

的A*寻径算法，也是一种带启发的搜索算法，利用路径评估函数，每次都选择距离出发点最近的位置开始搜索

3.剪枝策略  
对解空间穷举搜索时，如果有一些状态节点可以根据问题提供的信息明确地被判定为不可能演化出最优解，也就是说，从此节点开始遍历得到的子树，可能存在正确的解，但是肯定不是最优解，就可以跳过此状态节点的遍历，这将极大地提高算法的执行效率。这就是剪枝策略。

4.搜索算法的评估和收敛  
穷举法虽然被称为灵活的“通用算法”，但也不是万能的，穷举法最大的敌人是问题的规模。很多问题，当规模大到一定程度时，使用穷举法就只具有理论上的可行性。对某些问题，穷举法是最后的办法，但是问题规模又大到无法对解空间进行完整的搜索，这时候就需要对搜索算法进行评估，**并确定一些收敛原则。
