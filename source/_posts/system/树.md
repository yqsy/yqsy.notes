---
title: 树
date: 2017-11-25 20:34:29
categories: [系统底层]
---

<!-- TOC -->

- [3. 前序遍历/中序遍历/后序遍历](#3-前序遍历中序遍历后序遍历)
    - [3.1. 递归方式(深度优先)](#31-递归方式深度优先)
    - [3.2. 栈方式(深度优先)](#32-栈方式深度优先)
- [5. (中,后)(前,中)遍历方式生成二叉树](#5-中后前中遍历方式生成二叉树)
    - [5.1. 中序遍历和后序遍历树构造二叉树](#51-中序遍历和后序遍历树构造二叉树)
    - [5.2. 前序遍历和中序遍历树构造二叉树](#52-前序遍历和中序遍历树构造二叉树)

<!-- /TOC -->





<a id="markdown-3-前序遍历中序遍历后序遍历" name="3-前序遍历中序遍历后序遍历"></a>
# 3. 前序遍历/中序遍历/后序遍历
preorder inorder postorder

前/中/后指的是root节点在什么位置进行遍历,对应`中`左右/左`中`右/左右`中`  
`深度优先遍历`,在需要输出`中`的时候输出`中`

<a id="markdown-31-递归方式深度优先" name="31-递归方式深度优先"></a>
## 3.1. 递归方式(深度优先)

```python
def rescursive_pre(root):
    if not root:
        return
    print(root.val)
    rescursive_pre(root.left)
    rescursive_pre(root.right)
 
def rescursive_in(root):
    if not root:
        return
    rescursive_in(root.left)
    print(root.val)
    rescursive_in(root.right)
 
def rescursive_post(root):
    if not root:
        return
    rescursive_post(root.left)
    rescursive_post(root.right)
    print(root.val)
```

<a id="markdown-32-栈方式深度优先" name="32-栈方式深度优先"></a>
## 3.2. 栈方式(深度优先)
为什么用递归写极容易,可读性又高呢?因为临时的状态可以保存在栈上.随着递归深入,和递归出来,可以得到临时的状态以作输出.
循环没有临时的状态,只得循环把节点放入栈内(为了深度优先遍历).
拿起纸和笔,想想怎么push和pop节点,总结规律.

前序和后序比较简单,pop栈再push左push右
中序的思维方式不一样,要先push所有左子树

```python
def traverse_pre(root):
    if not root:
        return
    stack = []
    stack.append(root)
    while stack:
        node = stack.pop()
        print(node.val)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
 
def traverse_in(root):
    if not root:
        return
    stack = []
    while root or stack:
        while root:
            stack.append(root)
            root = root.left
        pop_node = stack.pop()
        print(pop_node.val)
        if pop_node.right:
            root = pop_node.right
 
def traverse_post(root):
    if not root:
        return
    stack = []
    result = []
    stack.append(root)
    while stack:
        node = stack.pop()
        result.append(node.val)
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    print(result[::-1])
```



<a id="markdown-5-中后前中遍历方式生成二叉树" name="5-中后前中遍历方式生成二叉树"></a>
# 5. (中,后)(前,中)遍历方式生成二叉树
example:  
树:  
{1, 2, 3, 4, 5, 6, 7, 8, 9}

前序: 1 2 4 8 9 5 3 6 7  
中序: 8 4 9 2 5 1 6 3 7  
后序: 8 9 4 5 2 6 7 3 1  
思路是:  
树是从上往下生成的,观察前序和后序,即可知道从上至下生长的方式.  
生长是两个节点一起长的,观察前序和后序,可分割成左右两块.  
怎么分割成两块?结合中序分析即可得出.  

<a id="markdown-51-中序遍历和后序遍历树构造二叉树" name="51-中序遍历和后序遍历树构造二叉树"></a>
## 5.1. 中序遍历和后序遍历树构造二叉树
```python
def build_tree_A_B(A, B):
    if len(A) == 0:
        return None
    if len(A) == 1:
        return TreeNode(A[0])
    val = A[0]
    idx = B.index(val)
    root = TreeNode(val)
    root.left = build_tree_A_B(A[1:idx + 1], B[0:idx])
    root.right = build_tree_A_B(A[idx + 1:len(A)], B[idx + 1:len(B)])
    return root
```

<a id="markdown-52-前序遍历和中序遍历树构造二叉树" name="52-前序遍历和中序遍历树构造二叉树"></a>
## 5.2. 前序遍历和中序遍历树构造二叉树
```python
def build_tree_B_C(B, C):
    if len(C) == 0:
        return None
    if len(C) == 1:
        return TreeNode(C[-1])
    val = C[-1]
    idx = B.index(val)
    root = TreeNode(val)
    root.left = build_tree_B_C(B[0:idx], C[0:idx])
    root.right = build_tree_B_C(B[idx + 1:len(B)], C[idx:len(C) - 1])
    return root
```